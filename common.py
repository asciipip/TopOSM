#!/usr/bin/python

"""common.py: Common utility functions for TopOSM"""

import os, time, sys
import functools
from os import path
from threading import Lock

import filelock
import influxdb

from env import *

__author__      = "Lars Ahlzen"
__copyright__   = "(c) Lars Ahlzen 2008-2011"
__license__     = "GPLv2"


class ErrorLog:
    lock = Lock()
    def log(self, message, exception = None):
        timestr = time.strftime('[%Y-%m-%d %H:%M:%S]')
        ErrorLog.lock.acquire()
        try:
            file = open(ERRORLOG, 'a')
            file.write("%s %s (%s)\n" % (timestr, message, str(exception)))
            file.close()
        except:
            print("Failed to write to the error log:")
            print("%s %s" % (sys.exc_info()[0], sys.exc_info()[1]))
        finally:
            ErrorLog.lock.release()        

errorLog = ErrorLog()


# global locking object for file system ops (e.g. creating directories)
fslock = filelock.FileLock('/tmp/lock.TopOSM.fslock')

def ensureDirExists(path):
    with fslock:
        if not os.path.isdir(path):
            os.makedirs(path)

def connect_to_influxdb():
    return influxdb.InfluxDBClient(
        host=INFLUX_HOST,
        port=INFLUX_PORT,
        username=INFLUX_USER,
        password=INFLUX_PASS,
        ssl=INFLUX_SSL,
        verify_ssl=True,
        database=INFLUX_DB)

@functools.total_ordering
class Tile:
    """Represents a single tile (or metatile)."""

    def __init__(self, z, x, y, is_metatile=False):
        self.z = z
        self.x = x
        self.y = y
        self.is_metatile = is_metatile

    @classmethod
    def fromstring(cls, str, is_metatile=False):
        """Creates a Tile instance from a string of the form z/x/y."""
        z, x, y = [ int(s) for s in str.split('/') ]
        return cls(z, x, y, is_metatile)

    @classmethod
    def fromjson(cls, o, ignored=False):
        """Takes a dict generated by Tile.tojson() and creates a new object
        instance from it."""
        return cls(o['z'], o['x'], o['y'], o['is_metatile'])

    def tojson(self):
        """Gives a dictionary representation of this object suitable for passing
        to json.dumps().  Tile.fromjson() is the inverse of this method."""
        return {'z': self.z, 'x': self.x, 'y': self.y, 'is_metatile': self.is_metatile}

    def __repr__(self):
        return 'Tile({0}, {1}, {2}, {3})'.format(self.z, self.x, self.y, self.is_metatile)

    def __str__(self):
        if self.is_metatile:
            return 'mt:{0}/{1}/{2}'.format(self.z, self.x, self.y)
        else:
            return '{0}/{1}/{2}'.format(self.z, self.x, self.y)

    def __eq__(self, other):
        if not isinstance(other, Tile):
            return NotImplemented
        return self.is_metatile == other.is_metatile and self.sort_key == other.sort_key

    def __lt__(self, other):
        if not isinstance(other, Tile):
            return NotImplemented
        elif self.is_metatile != other.is_metatile:
            return self.is_metatile < other.is_metatile
        else:
            return self.sort_key < other.sort_key

    def __hash__(self):
        return hash(self.is_metatile) | hash(self.z) | hash(self.x) | hash(self.y)

    @property
    def metatile(self):
        """Returns the metatile for this tile."""
        if self.is_metatile:
            return self
        else:
            return Tile(self.z, self.x // NTILES[self.z], self.y // NTILES[self.z], True)

    @property
    def sort_key(self):
        return (self.z, self.x, self.y)

    @property
    def keytile(self):
        if self.is_metatile:
            return Tile(self.z, self.x * NTILES[self.z], self.y * NTILES[self.z], False)
        else:
            return self

    def path(self, tileset, suffix='png'):
        if self.is_metatile:
            return getMetaTilePath(tileset, self.z, self.x, self.y, suffix)
        else:
            return getTilePath(tileset, self.z, self.x, self.y, suffix)

    def exists(self, tileset, suffix='png'):
        if self.is_metatile:
            return self.keytile.exists(tileset, suffix)
        else:
            return tileExists(tileset, self.z, self.x, self.y, suffix)

    def is_old(self):
        if self.is_metatile:
            return self.keytile.is_old()
        else:
            return tileIsOld(self.z, self.x, self.y)

    @property
    def is_valid(self):
        if self.is_metatile:
            return 0 <= self.x and self.x < 2**self.z // NTILES[self.z] and \
                   0 <= self.y and self.y < 2**self.z // NTILES[self.z]
        else:
            return 0 <= self.x and self.x < 2**self.z and \
                   0 <= self.y and self.y < 2**self.z


def getCachedMetaTileDir(mapname, z, x):
    return os.path.join(TEMPDIR, mapname, str(z), str(x))

def getCachedMetaTilePath(mapname, z, x, y, suffix = "png"):
    return os.path.join(getCachedMetaTileDir(mapname, z, x), str(y) + '.' + suffix)

def cachedMetaTileExists(mapname, z, x, y, suffix = "png"):
    return os.path.isfile(getCachedMetaTilePath(mapname, z, x, y, suffix))

def getMetaTileDir(mapname, z):
    return os.path.join(BASE_TILE_DIR, mapname, str(z))

def getMetaTilePath(mapname, z, x, y, suffix = "png"):
    return os.path.join(getMetaTileDir(mapname, z), \
        's' + str(x) + '_' + str(y) + '.' + suffix)

def getTileDir(mapname, z, x):
    return os.path.join(getMetaTileDir(mapname, z), str(x))

def getTilePath(mapname, z, x, y, suffix = "png"):
    return os.path.join(getTileDir(mapname, z, x), str(y) + '.' + suffix)

def tileExists(mapname, z, x, y, suffix = "png"):
    return os.path.isfile(getTilePath(mapname, z, x, y, suffix))

def tileIsOld(z, x, y):
    return b'user.toposm_dirty' in xattr.list(getTilePath(REFERENCE_TILESET, z, x, y))

def getTileSize(ntiles, includeBorder = True):
    if includeBorder:
        return TILE_SIZE * ntiles + 2 * BORDER_WIDTH
    else:
        return TILE_SIZE * ntiles
